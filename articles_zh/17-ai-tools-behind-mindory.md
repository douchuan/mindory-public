# Mindory 背后的 AI 工具实战总结：从生成到上线的性能与工程思考

Mindory 并非传统意义上的软件项目，而是**人类与多款 AI 系统协同开发**的。

本文梳理了 Mindory 研发中用到的 AI 工具，以及如何把 AIGC 内容（原型设计，代码，文档），打磨成可上线的生产级软件。

核心结论只有一句：
> AI 能快速搭出框架，但正确性、架构与性能，依然要靠人来把控。

---

## 一、ChatGPT：产品级战略搭档
### 主要作用
ChatGPT 在整个开发中，承担的是**战略与产品层角色**，而非简单的代码生成工具：
- 产品定义与方向梳理
- 关键决策：定价策略、App 视觉风格、官网风格
- 为其他 AI 工具编写高质量提示词
- 产品文案，及中英互译
- 商业模式验证
- 系统架构讨论与方案梳理

实际体验下来：
> ChatGPT 更像一位**联合创始人**，而不只是编码助手。

### 使用感受
- 整体表现符合预期
- 对话过长时，输入框会出现卡顿
- 上下文太重时，只能新开对话继续

有意思的细节：
- 迁移上下文时，AI 会智能过滤掉简单一次性问题
- 上下文切换流畅

### 局限
超长对话会明显降低 UI 响应速度，需要人工重置上下文、管理对话历史。
另外，由于使用的是免费版本，超出使用量后，ChatGPT 会切换低阶模型，让你有明显的降智的感觉。

---

## 二、Manus：视觉输出强，架构需清理
### 主要用途
主要用来生成 Mindory 官方官网，亮点很突出：
- 快速生成网站基础结构
- 所见即所得的设计流程
- UI 布局与配色成熟
- 生成代码符合 Next.js 设计范式 (Mindory 官网基于 Next.js 实现)

优点：
- 视觉风格统一、排版舒服
- 组件结构干净
- 默认审美在线

### 局限
- CSS 基于 Tailwind 生成, 虽然会产出 `global.css`，但实际并未被使用
- 部分布局数值直接硬编码在 TSX 中

带来的问题：
- 初始生成的代码，需要重构才能用于生产 

结论：
> Manus 视觉输出能力极强，但上线前必须做架构清理。

---

## 三、百度秒嗒：快速搭骨架，上线要解耦
### 主要用途
用来生成 Mindory 最初的应用框架。
项目技术栈：
- 基于 Rust
- 基于 Tauri 构建

秒嗒提供：
- 所见即所得生成
- 强大的 Mock 能力，便于快速原型验证

### Mock 设计观察
Mock 功能对早期验证非常有用，但仍有优化空间：
- 建议面向接口编程
- 明确标注哪些是 Mock 实现
- 清晰标记必须替换为真实服务的组件

否则团队容易踩坑：
- 把 Mock 逻辑直接上线
- 忽略临时脚手架代码

### 局限
- 初始生成的代码，需要重构才能用于生产 
- 不支持 Next.js 栈
- 会自动引入百度云服务
- 会注入秒嗒专属插件

带来风险：
- 厂商绑定
- 架构污染
- 可移植性下降

结论：
> 与 Manus 存在同样问题，做原型很强（可以替代 Axure 这类原型工具），但上线前必须仔细解耦。 

---

## 四、主力大模型：豆包（doubao-seed-1-6-flash-250828）
实际使用观察：
- 推理质量稳定优秀
- 性价比极高
- 适合生产环境部署

对比同类模型：
- 长上下文表现更稳定, 响应流畅

在高频推理场景中，实用性非常突出。

---

## 五、Trae：不错的 Copilot，但生成代码必须严格 review
### 优点
- 免费使用
- 适合快速出代码草稿

### 局限
- 必须人工仔细 Code Review 
- 容易抓错上下文重点
- 可能引入意料之外的 Bug
- 偶尔会丢失之前的修改

核心问题：
> 上下文对齐偏差。

AI 有时会卡在旧假设上，生成逻辑不一致的修改。
**每一次改动都必须 Code Review + 回归测试。**

---

## 六、整体研发体验：AI 是加速器，不是替代者
AI 工具极大提速了这些环节：
- 框架脚手架
- UI 生成
- 业务建模
- 文案撰写
- 结构原型搭建

尤其擅长：
- 快速产出第一版可运行代码
- 探索多种架构方案
- 生成重复样板代码

但必须清醒：
> AI 生成代码，默认**不具备直接上线条件**。
> 加速 ≠ 优化。

---

## 七、关键工程实践：AI 生成，人工把关
AI 生成的系统，必须配上严格的工程纪律。

### 7.1 永远 Code Review 生成代码
不要盲目信任输出，重点检查：
- 硬编码常量
- 隐藏依赖
- 错误导入
- 过度拉取数据
- 冗余抽象
- 架构捷径

AI 优化目标是“能跑的代码”，不是“最优代码”。

### 7.2 性能意识是必修课
AI 生成的实现通常：
- 功能正确
- Mock 友好
- 可读性不错
- 但**没有做性能优化**

在这些场景尤其致命：
- 跨语言调用
- 重数据库系统
- 聚合逻辑
- 高频操作

### 7.3 跨语言优化（以 Tauri 为例）
典型 Tauri 架构：
TypeScript ↔ Rust ↔ 数据库

AI 早期生成的常见问题：
- 一次只查一条记录
- 多次来回调用
- 在内存中过滤聚合
- 反复跨语言边界

能用，但性能极差。

更优方案：
- 单条 SQL 联表查询
- 在数据库层面直接过滤
- 用 SQL 函数做聚合
- 一次请求返回结构化结果

核心原则：
> 最小化跨语言通信。
> 数据在哪，计算就在哪。

### 7.4 把计算逻辑下沉到数据库
常见反面模式：
1. 查询原始数据
2. 把大量数据加载到内存
3. 在应用代码里过滤、聚合

后果：
- 内存暴涨
- CPU 占用高
- 延迟增加
- 带宽浪费

正确做法：
- 多用 SQL JOIN / GROUP BY
- 用 COUNT / SUM / AVG
- 加索引、用好 WHERE
- 深度优化查询

数据库天生擅长集合运算，应用内存不是。

原则：
> 在成本最低的地方做计算。

### 7.5 Mock 代码 ≠ 生产代码
AI 生成的脚手架通常：
- 用简化内存数据
- 忽略索引
- 跳过查询规划
- 没有批量逻辑

上线前必须：
- 替换 Mock 逻辑
- 加上合理索引
- 审查执行计划
- 对关键路径做基准测试

### 7.6 测试是硬性要求
单元测试必须覆盖：
- 核心业务逻辑
- 价格计算
- 分析统计系统
- 边界异常场景

只保证功能正确还不够，关键路径还要：
- 性能基准测试
- 压力测试
- 查询分析

### 7.7 交互改动必须做回归测试
AI 可能会无意识地：
- 删除原有逻辑
- 打断事件链
- 错误重置状态
- 引入隐蔽的竞态条件

但凡涉及代码更新，都要做完整回归。

---

## 八、最终思考：与 AI 协同，而非被 AI 主导
AI 工具是极强的加速器：
- 缩短第一版上线时间
- 支持快速迭代
- 降低样板代码成本
- 辅助战略思考

但它们做不到：
- 自动保证架构完整性
- 自动优化性能
- 取代严谨的工程能力

正确心态是：
> AI 加速迭代，人类把控正确、可扩展与性能。

Mindory 不是**由 AI 生成**的， 而是在持续的监督下**与 AI 协同开发**的。