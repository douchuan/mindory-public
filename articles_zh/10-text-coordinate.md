# Mindory 如何通过引文定位原文

Mindory 的一项核心承诺非常简单：

> **每一条 AI 生成的引文，都必须精准指向书中的原始位置。**

这听起来容易，但在实际实现中，需要在两套体系之间建立清晰、可靠的**定位模型**：
- **Embedding Chunks**: 供 AI 使用
- **Render Blocks**: 供阅读界面使用

---

## 1. Mindory 中的两个世界
同一本书，在 Mindory 中存在两套相互关联、但用途不同的文本视图。

### AI 世界: Embedding Chunks
- 文本被切分为 **Embedding Chunk**
- 每个分块：
  - 拥有固定长度
  - 用于语义检索

可以把分块理解为**检索单元**。

---

### 用户世界: Render Blocks
- 文本被切分为 **Render Block**
- 每个块：
  - 与用户屏幕上看到的内容完全一致
  - 拥有稳定的顺序（块索引）
  - 支持翻页、高亮、跳转

可以把渲染块理解为**阅读单元**。

---

## 2. 核心设计规则
Chunks 与 Render Blocks 共享同一套坐标系：

```
processed text offsets
```

这意味着：
- 每个 Embedding Chunk 都知道自己覆盖文本的哪一段
- 每个 Render Block 也知道自己覆盖文本的哪一段

这套共享参照系，就是连接两个世界的桥梁。

---

## 3. 一个直观的理解模型
把整本书想象成一长串连续文本：

```
Processed Text Timeline
------------------------------------------------------------>
0        100        200        300        400        500
```

**Render Blocks**：

```
[Block 0]--------|
                 [Block 1]--------|
                                  [Block 2]--------|
```

**Embedding Chunks**（为保持语义连贯, 会相互重叠）：

```
    [Chunk A]-----------------------|
                     [Chunk B]-----------------------|
```

一个 Embedding Chunk 可能**覆盖多个 Render Blocks**，这是设计预期，也是正常行为。

---

## 4. 用户点击 AI 引文时发生了什么？
当 AI 展示一段引文，用户点击它时，Mindory 只需要回答一个问题：

> **应该把读者带到书中的哪个位置？**

整个过程分为清晰的五步。

---

## 5. 定位逻辑

### 步骤 1：找到 Embedding Chunk 覆盖的所有 Render Blocks
每个嵌入分块都有明确的文本区间：
```
chunk.range = [start_offset, end_offset)
```

因此可以找到所有区间与之重叠的渲染块：

```pseudo
blocks = findRenderBlocksWhere(
    block.range overlaps chunk.range
)
```

结果示例：
```
[Block 12] [Block 13] [Block 14]
```

这些块共同构成了该分块对应的完整阅读上下文。

---

### 步骤 2：选择锚点块
一个分块可能跨多个块，因此需要**唯一锚点**。

Mindory 使用简单且稳健的规则：
1. 优先找到**真正包含引文片段**的块
2. 若找不到，自动选择**中间块**作为兜底

```pseudo
anchor = blocks.find(block contains quote)
if anchor is null:
    anchor = blocks[middle]
```

这种方式不做猜测，同时对用户体验自然友好。

---

### 步骤 3：准备弹窗上下文内容
为保证上下文完整，Mindory 会展示**所有相关块**，而非只展示一个：

```
弹窗内容：
[Block 12]
[Block 13]
[Block 14]
```

让用户看到足够的前后文，真正理解引文来源。

---

### 步骤 4：将块索引转换为页码
渲染块在阅读时会分页展示。

假设每页显示 10 个块：

```pseudo
pageIndex = anchorBlock.index / 10
```

示例：
```
Block index: 137
Blocks per page: 10

Page index = 13
```

这一步将文本位置直接映射为阅读页码。

---

### 步骤 5：加载并展示目标页
最终，Mindory 加载包含锚点块的页面：

```pseudo
start = pageIndex * pageSize
pageBlocks = loadBlocks(start, pageSize)
```

弹窗会精准打开到引文所在的真实位置。

---

## 6. 这套设计为何有效？

### 不做任何猜测
- 不使用模糊匹配
- 不使用语言特定技巧

一切都基于**位置**。

---

### 稳定、可复现、可测试
同一本书 + 同一个分块 = 永远得到相同的渲染块。

---

### 用户信任
当用户点击引文时：
- 高亮与原文完全一致
- 跳转位置准确自然
- 系统显得可靠

对阅读产品而言，这一点至关重要。

---

## 7. 一张图记住整个逻辑

```
书籍文本（处理后）
---------------------------------------------------->

渲染块：
|----B0----|----B1----|----B2----|----B3----|

嵌入分块：
        |---------C7---------|
                   |---------C8---------|

用户点击来自 C7 的引文
            ↓
查找重叠块：B0, B1, B2
            ↓
选择锚点：B2
            ↓
跳转到包含 B2 的页面
```

---

## 8. 核心总结
Mindory 在这件事上没有追求“巧妙”。

它只依赖一个简单的思想：

> **如果所有视图共享同一坐标，定位就会简单且可靠**

- Embedding Chunk 帮助 AI 理解内容
- Render Block 帮助用户阅读内容
- offset 连接两个世界

正是这种连接，让 AI 辅助阅读显得**可信**。